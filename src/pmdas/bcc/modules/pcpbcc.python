#
# Copyright (C) 2017-2018 Marko Myllynen <myllynen@redhat.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
""" PCP BCC PMDA module base class """

from ctypes import c_int

# pylint: disable=too-many-instance-attributes
class PCPBCCBase(object):
    """ PCP BCC Base Class """
    def __init__(self, module, config, log, err):
        """ Constructor """
        self._who = module
        self._log = log
        self._err = err

        self.bpf = None
        self.insts = {}
        self.items = []

        self.pmdaIndom = None # pylint: disable=invalid-name
        self.config = config
        self.debug = False

        for opt in self.config.options(self._who):
            if opt == 'debug':
                self.debug = self.config.getboolean(self._who, opt)

        if self.debug:
            self.log("Debug logging enabled.")

    def log(self, msg):
        """ Log a message """
        self._log(self._who + ": " + msg)

    def err(self, msg):
        """ Log an error """
        self._err(self._who + ": " + msg)

    def metrics(self):
        """ Get metric definitions """
        raise NotImplementedError

    def helpers(self, pmdaIndom): # pylint: disable=invalid-name
        """ Register helper function references """
        self.pmdaIndom = pmdaIndom

    def compile(self):
        """ Compile BPF """
        raise NotImplementedError

    def refresh(self):
        """ Refresh BPF data """
        raise NotImplementedError

    def bpfdata(self, item, inst):
        """ Return BPF data as PCP metric value """
        raise NotImplementedError

    def label_cluster(self): # pylint: disable=no-self-use
        """ Cluster labels """
        return '{}'

    def label_instance(self, inst): # pylint: disable=no-self-use,unused-argument
        """ Label callback for instance """
        return '{}'

    def cleanup(self):
        """ Clean up at exit """
        if self.bpf is not None:
            self.bpf.cleanup()
        self.bpf = None
        self.log("BPF detached.")

    #
    # Helpers for modules
    #

    @classmethod
    def read_histogram(cls, table, cache):
        """ Read BPF histogram data """
        buckets = []
        max_high = -1

        for key, val in table.items():
            if key.value == 0:
                continue

            low = (1 << key.value) >> 1
            high = (1 << key.value) - 1
            if low == high:
                low -= 1
            key = str(low) + "-" + str(high)
            if key not in cache:
                cache[key] = 0
            cache[key] += val.value

            buckets.append((low, high))
            if high > max_high and cache[key] > 0:
                max_high = high

        # Always show at least the first bucket, if one
        if max_high == -1 and buckets:
            max_high = buckets[0][1]

        return {str(low) + "-" + str(high) : c_int(1) for low, high in buckets if high <= max_high}

    @classmethod
    def read_probe_conf(cls, conf):
        """ Read tracepoint/uprobe/usdt probes from a file """
        if ":" in conf:
            return conf.split(",")
        if not conf.startswith("/"):
            from os import path
            conf = path.dirname(__file__) + "/../" + conf
        return [l.strip() for l in open(conf).readlines() if l.strip() != "" and '#' not in l]

    @classmethod
    def get_proc_info(cls, process):
        """ Get process info for given PIDs or process name """

        def get_pids(procname):
            """ Get PIDs for a process """
            from os import listdir
            import re
            pids = []
            comp = re.compile(r'\A' + procname + r'\Z')
            for dirname in listdir("/proc"):
                try:
                    with open("/proc/%s/cmdline" % dirname, "rb") as file:
                        cmdline = file.read().decode().split("\x00")
                        if procname == cmdline[0] or re.match(comp, " ".join(cmdline[:-1])):
                            pids.append(int(dirname))
                except Exception: # pylint: disable=broad-except
                    continue
            return pids

        def get_proc_details(pids):
            """ Get process info for PIDs """
            procinfo = []
            for pid in pids:
                try:
                    with open("/proc/%s/cmdline" % str(pid), "rb") as file:
                        cmdline = file.read().decode().split("\x00")
                        procinfo.append([pid, cmdline[0], " ".join(cmdline[1:-1])])
                except Exception: # pylint: disable=broad-except
                    continue
            return procinfo

        try:
            pids = [int(i) for i in process.split(",")]
        except ValueError:
            pids = get_pids(process)

        return get_proc_details(pids)
