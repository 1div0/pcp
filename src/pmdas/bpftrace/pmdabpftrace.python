#!/usr/bin/env python
#
# Copyright (c) 2019 Red Hat.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
"""bpftrace PMDA"""

import os
import atexit
from ctypes import c_int

import cpmapi as c_api
from cpmda import PMDA_FETCH_NOVALUES
from pcp.pmda import PMDA, pmdaMetric, pmdaIndom
from pcp.pmapi import pmUnits, pmContext as PCP

from bpftrace import BPFtrace, BPFtraceError


class Consts: # pylint: disable=too-few-public-methods
    """PMDA constants"""
    class Control:
        """constants of control cluster"""
        Cluster = 0
        Register = 0
        Deregister = 1
        Start = 2
        Stop = 3
        Scripts = 4
    class Script:
        """constants of script clusters"""
        Status = 0
        Pid = 1
        ExitCode = 2
        Output = 3
        Probes = 4
        Script = 5

class BPFtraceScript:
    """manage metrics for a bpftrace instance"""

    def __init__(self, pmda, cluster, name, script):
        self.pmda = pmda
        self.cluster = cluster
        self.name = name
        self.script = script # contains the unmodified script
        self.bpftrace = BPFtrace(pmda.log, script)
        self.state = self.bpftrace.state()

        self.item_to_var = {}
        self.indom_ids = {}
        self.indoms = {}
        self.metrics = {}

    def start(self):
        """start bpftrace"""
        return self.bpftrace.start()

    def stop(self):
        """stop bpftrace"""
        return self.bpftrace.stop()

    @classmethod
    def normalize_variable_name(cls, var_name):
        """normalize bpftrace variable name to conform PCP metric names"""
        metric_name = var_name[1:]
        if not metric_name:
            metric_name = 'root'
        return metric_name

    def register_metrics(self):
        """register metrics for this bpftrace instance"""
        self.status_metric = pmdaMetric(
            self.pmda.pmid(self.cluster, Consts.Script.Status), c_api.PM_TYPE_STRING,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        )
        self.pmda.add_metric('bpftrace.scripts.{}.status'.format(self.name), self.status_metric)

        self.pid_metric = pmdaMetric(
            self.pmda.pmid(self.cluster, Consts.Script.Pid), c_api.PM_TYPE_U32,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        )
        self.pmda.add_metric('bpftrace.scripts.{}.pid'.format(self.name), self.pid_metric)

        self.exit_code_metric = pmdaMetric(
            self.pmda.pmid(self.cluster, Consts.Script.ExitCode), c_api.PM_TYPE_U32,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        )
        self.pmda.add_metric('bpftrace.scripts.{}.exit_code'.format(self.name),
                             self.exit_code_metric)

        self.output_metric = pmdaMetric(
            self.pmda.pmid(self.cluster, Consts.Script.Output), c_api.PM_TYPE_STRING,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        )
        self.pmda.add_metric('bpftrace.scripts.{}.output'.format(self.name), self.output_metric)

        self.probes_metric = pmdaMetric(
            self.pmda.pmid(self.cluster, Consts.Script.Probes), c_api.PM_TYPE_U32,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        )
        self.pmda.add_metric('bpftrace.scripts.{}.probes'.format(self.name), self.probes_metric)

        self.script_metric = pmdaMetric(
            self.pmda.pmid(self.cluster, Consts.Script.Script), c_api.PM_TYPE_STRING,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        )
        self.pmda.add_metric('bpftrace.scripts.{}.script'.format(self.name), self.script_metric)

        # bpftrace needs to be started
        for item_no, (var_name, var_def) in enumerate(self.bpftrace.var_defs.items(), 100):
            if var_def.single:
                indom_id = c_api.PM_INDOM_NULL
            else:
                indom_id = self.pmda.indom(item_no)
                indom = pmdaIndom(indom_id, {})
                self.pmda.add_indom(indom)
                self.indom_ids[var_name] = indom_id
                self.indoms[var_name] = indom

            metric = pmdaMetric(
                self.pmda.pmid(self.cluster, item_no), c_api.PM_TYPE_U64,
                indom_id, var_def.semantics, pmUnits()
            )
            self.pmda.add_metric('bpftrace.scripts.{}.data.{}'.format(
                self.name, self.normalize_variable_name(var_name)), metric)
            self.metrics[var_name] = metric
            self.item_to_var[item_no] = var_name

    def deregister_metrics(self):
        """remove bpftrace metrics for this bpftrace instance"""
        self.pmda.remove_metric('bpftrace.scripts.{}.status'.format(self.name), self.status_metric)
        self.pmda.remove_metric('bpftrace.scripts.{}.pid'.format(self.name), self.pid_metric)
        self.pmda.remove_metric('bpftrace.scripts.{}.exit_code'.format(self.name),
                                self.exit_code_metric)
        self.pmda.remove_metric('bpftrace.scripts.{}.output'.format(self.name), self.output_metric)
        self.pmda.remove_metric('bpftrace.scripts.{}.probes'.format(self.name), self.probes_metric)
        self.pmda.remove_metric('bpftrace.scripts.{}.script'.format(self.name), self.script_metric)
        for var_name in self.bpftrace.var_defs:
            self.pmda.remove_metric('bpftrace.scripts.{}.data.{}'.format(
                self.name, self.normalize_variable_name(var_name)), self.metrics[var_name])

    def refresh_state(self):
        """refreshes state from bpftrace application"""
        self.state = self.bpftrace.state()

    def refresh_callback(self):
        """PMDA refresh callback for this bpftrace instance"""
        self.refresh_state()

        # refresh instance domains
        for var_name, var_def in self.bpftrace.var_defs.items():
            # parser found variable definition in script, but variable
            # doesn't exist in bpftrace output due to an error
            if not var_def.single and var_name in self.state.maps:
                self.indoms[var_name].set_instances(self.indom_ids[var_name], {
                    key:c_int(1) for key in self.state.maps[var_name]
                })

    def fetch_callback(self, item, inst): # pylint: disable=too-many-return-statements
        """PMDA fetch callback for this bpftrace instance"""
        if item == Consts.Script.Status:
            return [self.state.status, 1]
        elif item == Consts.Script.Pid:
            if self.state.pid:
                return [self.state.pid, 1]
            return [PMDA_FETCH_NOVALUES, 0]
        elif item == Consts.Script.ExitCode:
            if self.state.exit_code:
                return [self.state.exit_code, 1]
            return [PMDA_FETCH_NOVALUES, 0]
        elif item == Consts.Script.Output:
            return [self.state.output, 1]
        elif item == Consts.Script.Probes:
            return [self.state.probes, 1]
        elif item == Consts.Script.Script:
            return [self.bpftrace.script, 1]
        else:
            var_name = self.item_to_var[item]
            if var_name not in self.state.maps:
                return [PMDA_FETCH_NOVALUES, 0]
            if self.bpftrace.var_defs[var_name].single:
                return [self.state.maps[var_name], 1]
            else:
                key = self.indoms[var_name].inst_name_lookup(inst)
                return [self.state.maps[var_name][key], 1]
        return [c_api.PM_ERR_PMID, 0]


class BPFtracePMDA(PMDA):
    """bpftrace PMDA"""

    def __init__(self, name, domain):
        super(BPFtracePMDA, self).__init__(name, domain)

        self.configfile = PCP.pmGetConfig('PCP_PMDAS_DIR')
        self.configfile += '/' + name + '/' + name + '.conf'

        self.connect_pmcd()

        self.next_script_no = 1 # same as cluster
        self.script_instances = {}
        self.script_indom_id = None
        self.script_indom = None
        self.register_metrics()

        self.set_refresh(self.refresh_callback)
        self.set_fetch_callback(self.fetch_callback)
        self.set_store_callback(self.store_callback)

        @atexit.register
        def cleanup(): # pylint: disable=unused-variable
            """Cleanup"""
            if not os.environ.get('PCP_PYTHON_DOMAIN') and not os.environ.get('PCP_PYTHON_PMNS'):
                for script in self.script_instances.values():
                    script.refresh_state()
                    if script.state.status == 'started':
                        script.stop()

    def register_metrics(self):
        """register control metrics"""
        self.register_value = ''
        self.add_metric('bpftrace.control.register', pmdaMetric(
            self.pmid(Consts.Control.Cluster, Consts.Control.Register), c_api.PM_TYPE_STRING,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        ))

        self.deregister_value = ''
        self.add_metric('bpftrace.control.deregister', pmdaMetric(
            self.pmid(Consts.Control.Cluster, Consts.Control.Deregister), c_api.PM_TYPE_STRING,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        ))

        self.start_value = ''
        self.add_metric('bpftrace.control.start', pmdaMetric(
            self.pmid(Consts.Control.Cluster, Consts.Control.Start), c_api.PM_TYPE_STRING,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        ))

        self.stop_value = ''
        self.add_metric('bpftrace.control.stop', pmdaMetric(
            self.pmid(Consts.Control.Cluster, Consts.Control.Stop), c_api.PM_TYPE_STRING,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        ))

        self.script_indom_id = self.indom(0)
        self.script_indom = pmdaIndom(self.script_indom_id, {})
        self.add_indom(self.script_indom)
        self.add_metric('bpftrace.control.scripts', pmdaMetric(
            self.pmid(Consts.Control.Cluster, Consts.Control.Scripts), c_api.PM_TYPE_STRING,
            self.script_indom_id, c_api.PM_SEM_INSTANT, pmUnits()
        ))

    def refresh_script_instances(self):
        """update bpftrace scripts indom"""
        self.script_indom.set_instances(self.script_indom_id, {
            script.name:c_int(1) for script in self.script_instances.values()
        })

    def find_script_by_name(self, name):
        """find script by name"""
        for script in self.script_instances.values():
            if script.name == name:
                return script
        return None

    def register_script(self, code):
        """register a new bpftrace script"""
        # check for an identical script
        for script in self.script_instances.values():
            if script.script == code:
                self.register_value = script.name
                return 0

        script_cluster = self.next_script_no
        name = 'script{}'.format(script_cluster)
        script = BPFtraceScript(self, script_cluster, name, code)
        self.next_script_no += 1

        try:
            script.start()
        except BPFtraceError as e:
            self.register_value = str(e)
            return 0

        script.register_metrics()
        self.script_instances[script_cluster] = script
        self.refresh_script_instances()
        self.register_value = name
        return 0

    def deregister_script(self, name):
        """deregister a bpftrace script"""
        script = self.find_script_by_name(name)
        if not script:
            self.deregister_value = 'script not found'
            return 0

        script.deregister_metrics()
        script.refresh_state()
        if script.state.status == 'started':
            script.stop()
        del self.script_instances[script.cluster]
        self.refresh_script_instances()
        self.deregister_value = 'success'
        return 0

    def store_callback(self, cluster, item, inst, val): # pylint: disable=too-many-return-statements
        """PMDA store callback"""
        if cluster == Consts.Control.Cluster:
            if item == Consts.Control.Register:
                return self.register_script(val)
            elif item == Consts.Control.Deregister:
                return self.deregister_script(val)
            elif item == Consts.Control.Start:
                script = self.find_script_by_name(val)
                if not script:
                    self.start_value = 'script not found'
                    return 0
                try:
                    script.start()
                    self.start_value = 'success'
                except BPFtraceError as e:
                    self.start_value = str(e)
                return 0
            elif item == Consts.Control.Stop:
                script = self.find_script_by_name(val)
                if not script:
                    self.stop_value = 'script not found'
                    return 0
                try:
                    script.stop()
                    self.stop_value = 'success'
                except BPFtraceError as e:
                    self.stop_value = str(e)
                return 0

        return c_api.PM_ERR_PMID

    def refresh_callback(self, cluster):
        """PMDA refresh callback"""
        if cluster == Consts.Control.Cluster:
            return None
        else:
            return self.script_instances[cluster].refresh_callback()

    def fetch_callback(self, cluster, item, inst): # pylint: disable=too-many-return-statements
        """PMDA fetch callback"""
        if cluster == Consts.Control.Cluster:
            if item == Consts.Control.Register:
                val = self.register_value
                self.register_value = ''
                return [val, 1]
            elif item == Consts.Control.Deregister:
                val = self.deregister_value
                self.deregister_value = ''
                return [val, 1]
            elif item == Consts.Control.Start:
                val = self.start_value
                self.start_value = ''
                return [val, 1]
            elif item == Consts.Control.Stop:
                val = self.stop_value
                self.stop_value = ''
                return [val, 1]
            elif item == Consts.Control.Scripts:
                name = self.script_indom.inst_name_lookup(inst)
                script = self.find_script_by_name(name)
                if script:
                    return [script.script, 1]
                return [PMDA_FETCH_NOVALUES, 0]
        else:
            return self.script_instances[cluster].fetch_callback(item, inst)
        return [c_api.PM_ERR_PMID, 0]

if __name__ == '__main__':
    BPFtracePMDA('bpftrace', 151).run()
