#!/usr/bin/env python
#
# Copyright (c) 2019 Red Hat.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
"""bpftrace PMDA"""

import os
import re
import atexit
from ctypes import c_int

import cpmapi as c_api
from cpmda import PMDA_FETCH_NOVALUES
from pcp.pmda import PMDA, pmdaMetric, pmdaIndom
from pcp.pmapi import pmUnits, pmContext as PCP

from bpftrace import BPFtrace, BPFtraceError


class Consts: # pylint: disable=too-few-public-methods
    """PMDA constants"""
    class Control:
        """constants of control cluster"""
        Cluster = 0
        Register = 0
        Deregister = 1
        Scripts = 2
    class Script:
        """constants of script clusters"""
        Pid = 0
        Probes = 1


class BPFtraceMetric:
    def __init__(self, pmda, cluster, name, item_no, single, var_name):
        self.pmda = pmda
        self.cluster = cluster
        self.name = name
        self.item_no = item_no
        self.single = single
        self.var_name = var_name

        if single:
            self.instance = None
        else:
            self.instances = {}

    def register(self):
        if self.single:
            self.indom_id = c_api.PM_INDOM_NULL
        else:
            self.indom_id = self.pmda.indom(self.item_no)
            self.indom = pmdaIndom(self.indom_id, self.instances)
            self.pmda.add_indom(self.indom)

        self.metric = pmdaMetric(
            self.pmda.pmid(self.cluster, self.item_no), c_api.PM_TYPE_U64,
            self.indom_id, c_api.PM_SEM_INSTANT, pmUnits()
        )
        self.pmda.add_metric('bpftrace.scripts.{}.data.{}'.format(self.name, self.var_name), self.metric)

    def deregister(self):
        self.pmda.remove_metric('bpftrace.scripts.{}.data.{}'.format(self.name, self.var_name), self.metric)

    def update(self, val):
        if self.single:
            self.instance = val
        else:
            self.instances = val
            for key in val:
                self.pmda.log("logger "+str(key))
            self.indom.set_instances(self.indom_id,
                                    {key:c_int(1) for key in self.instances})

    def fetch(self, inst):
        if self.single:
            return [self.instance, 1]
        else:
            key = self.indom.inst_name_lookup(inst)
            return [self.instances[key], 1]

class BPFtraceScript(BPFtrace):
    """manage metrics for a bpftrace instance"""

    def __init__(self, pmda, cluster, name, script):
        super(BPFtraceScript, self).__init__(pmda.log, script)
        self.pmda = pmda
        self.cluster = cluster
        self.name = name
        self.metrics = {}
        self.item_to_metric = {}

    def register_metrics(self):
        """register metrics for this bpftrace instance"""
        self.pid_metric = pmdaMetric(
            self.pmda.pmid(self.cluster, Consts.Script.Pid), c_api.PM_TYPE_U32,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        )
        self.pmda.add_metric('bpftrace.scripts.{}.pid'.format(self.name), self.pid_metric)

        self.probes_metric = pmdaMetric(
            self.pmda.pmid(self.cluster, Consts.Script.Probes), c_api.PM_TYPE_U32,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        )
        self.pmda.add_metric('bpftrace.scripts.{}.probes'.format(self.name), self.probes_metric)

    def deregister_metrics(self):
        """remove bpftrace metrics for this bpftrace instance"""
        self.pmda.remove_metric('bpftrace.{}.pid'.format(self.name), self.pid_metric)
        self.pmda.remove_metric('bpftrace.{}.probes'.format(self.name), self.probes_metric)
        for metric in self.metrics:
            metric.deregister()

    def refresh_callback(self):
        """PMDA refresh callback for this bpftrace instance"""
        if not self.started:
            return

        for var, val in self.data().items():
            if var in self.metrics:
                self.metrics[var].update(val)
            else:
                item_no = 10 + len(self.metrics)
                metric_name = var[1:]
                if not metric_name:
                    metric_name = 'root'
                metric = BPFtraceMetric(self.pmda, self.cluster, self.name, item_no, not isinstance(val, dict), metric_name)
                metric.register()
                metric.update(val)
                self.metrics[var] = metric
                self.item_to_metric[item_no] = metric

    def fetch_callback(self, item, inst):
        """PMDA fetch callback for this bpftrace instance"""
        if not self.started:
            return [PMDA_FETCH_NOVALUES, 0]

        if item == Consts.Script.Pid:
            if self.pid:
                return [self.pid, 1]
            else:
                return [PMDA_FETCH_NOVALUES, 0]
        elif item == Consts.Script.Probes:
            if self.probes:
                return [self.probes, 1]
            else:
                return [PMDA_FETCH_NOVALUES, 0]
        elif item in self.item_to_metric:
            metric = self.item_to_metric[item]
            return metric.fetch(inst)
        return [c_api.PM_ERR_PMID, 0]


class BPFtracePMDA(PMDA):
    """bpftrace PMDA"""

    def __init__(self, name, domain):
        super(BPFtracePMDA, self).__init__(name, domain)

        self.configfile = PCP.pmGetConfig('PCP_PMDAS_DIR')
        self.configfile += '/' + name + '/' + name + '.conf'

        self.connect_pmcd()
        self.register_metrics()

        self.set_refresh(self.refresh_callback)
        self.set_fetch_callback(self.fetch_callback)
        self.set_store_callback(self.store_callback)

        @atexit.register
        def cleanup(): # pylint: disable=unused-variable
            """Cleanup"""
            if not os.environ.get('PCP_PYTHON_DOMAIN') and not os.environ.get('PCP_PYTHON_PMNS'):
                for script in self.script_instances.values():
                    script.stop()

    def register_metrics(self):
        """register control metrics"""
        self.register_value = ''
        self.add_metric('bpftrace.control.register', pmdaMetric(
            self.pmid(Consts.Control.Cluster, Consts.Control.Register), c_api.PM_TYPE_STRING,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        ))

        self.deregister_value = ''
        self.add_metric('bpftrace.control.deregister', pmdaMetric(
            self.pmid(Consts.Control.Cluster, Consts.Control.Deregister), c_api.PM_TYPE_STRING,
            c_api.PM_INDOM_NULL, c_api.PM_SEM_INSTANT, pmUnits()
        ))

        self.script_instances = {}
        self.script_indom_id = self.indom(0)
        self.script_indom = pmdaIndom(self.script_indom_id, self.script_instances)
        self.add_indom(self.script_indom)
        self.add_metric('bpftrace.control.scripts', pmdaMetric(
            self.pmid(Consts.Control.Cluster, Consts.Control.Scripts), c_api.PM_TYPE_STRING,
            self.script_indom_id, c_api.PM_SEM_INSTANT, pmUnits()
        ))

    def get_script_name(self):
        """returns next free script name and number"""
        for i in range(1, 1000):
            if 'script{}'.format(i) not in self.script_instances:
                return i, 'script{}'.format(i)
        return None

    def refresh_script_instances(self):
        """update bpftrace scripts indom"""
        self.script_indom.set_instances(self.script_indom_id,
                                        {name:c_int(1) for name in self.script_instances})

    def store_callback(self, cluster, item, inst, val):
        """PMDA store callback"""
        if cluster == Consts.Control.Cluster:
            if item == Consts.Control.Register:
                # TODO: check for existing scripts with same content
                no, name = self.get_script_name()
                script = BPFtraceScript(self, no, name, val)

                try:
                    script.start()
                except BPFtraceError as e:
                    self.register_value = str(e)
                    return 0

                script.register_metrics()
                script.refresh_callback()
                self.script_instances[name] = script
                self.refresh_script_instances()
                self.register_value = name
                return 0
            elif item == Consts.Control.Deregister:
                self.script_instances[val].deregister_metrics()
                self.script_instances[val].stop()
                del self.script_instances[val]
                self.refresh_script_instances()
                self.deregister_value = 'success'
                return 0

        return c_api.PM_ERR_PMID

    def refresh_callback(self, cluster):
        """PMDA refresh callback"""
        script_name = 'script{}'.format(cluster)
        if script_name in self.script_instances:
            return self.script_instances[script_name].refresh_callback()

    def fetch_callback(self, cluster, item, inst):
        """PMDA fetch callback"""
        self.log("type "+str(type(cluster)))
        if cluster == Consts.Control.Cluster:
            if item == Consts.Control.Register:
                val = self.register_value
                self.register_value = ''
                return [val, 1]
            elif item == Consts.Control.Deregister:
                val = self.deregister_value
                self.deregister_value = ''
                return [val, 1]
            elif item == Consts.Control.Scripts:
                name = self.script_indom.inst_name_lookup(inst)
                return [self.script_instances[name].script, 1]
        else:
            script_name = 'script{}'.format(cluster)
            if script_name in self.script_instances:
                return self.script_instances[script_name].fetch_callback(item, inst)
        return [c_api.PM_ERR_PMID, 0]

if __name__ == '__main__':
    BPFtracePMDA('bpftrace', 151).run()
