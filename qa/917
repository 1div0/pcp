#!/bin/sh
# PCP QA Test No. 917
# SELinux Testing
#
# Copyright (c) 2017-2018 Red Hat Inc.  All Rights Reserved.
#

seq=`basename $0`
echo "QA output created by $seq"

# get standard environment, filters and checks
. ./common.product
. ./common.filter
. ./common.check

policy_name="pcpupstream"
policy_file="$PCP_VAR_DIR/selinux/$policy_name.pp"
which sedismod >/dev/null 2>&1 || _notrun "sedismod tool not installed (module disassembly)"
which semodule >/dev/null 2>&1 || _notrun "semodule tool not installed"
which seinfo >/dev/null 2>&1 || _notrun "seinfo tool not installed"
( seinfo -t 2>&1 | grep 'Default policy search failed: No such file or directory' >/dev/null ) && _notrun "seinfo version bad: can't load default policy"
[ -f "$policy_file" ] || _notrun "upstream policy package not installed"
$sudo semodule -l 2>&1 | grep -q $policy_name || _notrun "upstream policy package not loaded"

seinfo --common >/dev/null 2>&1
if [ $? -eq 0 ]
then
    common_flag="--common"
else
    common_flag=""
fi

_filter_semodule()
{
    awk '{ print $1 }'
}

_filter_sedismod()
{
    sed -n '/--- begin avrule block ---/,$p'
}
_filter_sedismod1()
{
    sed -e '/^Command/d'
}
_filter_outfile()
{
    sed -f $tmp.sed \
    | awk \
	-v container_tmpfs_t="$container_runtime_tmpfs_t" \
	-v class_status="$class_status" \
	-v systemd_systemctl_unit_file_t="$systemd_systemctl_unit_file_t" \
	-v devlog_t="$devlog_t" \
	-v init_t="$init_t" \
	-v sock_file_getattr="$sock_file_getattr" \
	-v unconfined_service="$unconfined_service" \
	-v mock_var_lib="$mock_var_lib" \
        -v non_auth_type="$non_auth_type" \
        -v non_security_type="$non_security_type" \
    '{
	if (container_tmpfs_t == "" && /container_runtime_tmpfs_t/)
	   !/container_runtime_tmpfs_t/ ;
    	else if (systemd_systemctl_unit_dir_t == "" && /systemd_unit_dir_t/)
	   !/systemd_unit_dir_t/ ;
	else if (devlog_t == "" && /devlog_t/)
	   !/devlog_t/ ;
	else if (init_t == "" && /init_t/)
	   !/init_t/ ;
        else if (class_status == "" && /system.*status/)
           !/system.*status/ ;
	else if (sock_file_getattr == "" && /gpmctl_t/)
	   !/gpmctl_t/ ;
        else if (non_auth_type != "" && /non_security_file_type/)
            !/non_security_file_type/ ;
	else
	   print;
    }'
}

status=1	# failure is the default!
$sudo rm -rf $tmp $tmp.* $seq.full
trap "cd $here; $sudo rm -rf $tmp $tmp.*; exit \$status" 0 1 2 3 15

# use logic from configure.ac to build list of optional types that are
# not present on this system and need to be culled from $seq.out.in
#
seinfo -t >$tmp.types
echo '/^#/d' >$tmp.sed
echo '/^!/s// /' >>$tmp.sed
for type in container_runtime_t nsfs_t docker_var_lib_t svirt_lxc_net_t \
	    systemd_unit_file_t systemd_systemctl_exec_t unreserved_port_t \
	    tracefs_t mock_var_lib_t unconfined_service_t numad_t \
	    wap_wsp_port_t rpm_var_lib_t
do
    if grep "^[ 	][ 	]*$type\$" $tmp.types >/dev/null
    then
	:
    else
	echo "/^  *$type\$/d" >>$tmp.sed
	# and some missing types => rules to be culled
	#
	case "$type"
	in
	    nsfs_t)
		echo '/allow \[pcp_pmcd_t] \[nsfs_t]/d' >>$tmp.sed
		;;
	    unreserved_port_t)
		echo '/allow \[pcp_pmcd_t] \[unreserved_port_t]/d' >>$tmp.sed
		echo '/allow \[pcp_pmmgr_t] \[unreserved_port_t]/d' >>$tmp.sed
		;;
	    tracefs_t)
		echo '/allow \[pcp_pmcd_t] \[tracefs_t]/d' >>$tmp.sed
		;;
	    numad_t)
		echo '/allow \[pcp_pmcd_t] \[numad_t]/d' >>$tmp.sed
		;;
	    rpm_var_lib_t)
		echo '/allow \[pcp_pmcd_t] \[rpm_var_lib_t]/d' >>$tmp.sed
		;;
	esac
    fi
done

# now the class ones ... also from configure.ac
if seinfo -x --class=system $common_flag 2>&1 \
   | grep '^[ 	][ 	]*status$' >/dev/null
then
    :
else
    # in configure.ac and src/selinux/GNUlocadefs but no longer used in any
    # rules in src/selinux/pcpupstream.te.in, so we can ignore it here
    #
    :
fi

if seinfo -x --class=sock $common_flag 2>&1 \
   | grep '^[ 	][ 	]*status$' >/dev/null
then
    :
else
    # in configure.ac and src/selinux/GNUlocadefs but no longer used in any
    # rules in src/selinux/pcpupstream.te.in, so we can ignore it here
    #
    :
fi

if seinfo -x --class=cap_userns $common_flag 2>&1 \
   | grep '^[ 	][ 	]*sys_ptrace$' >/dev/null
then
    :
else
    echo '/allow \[pcp_pmie_t] .* \[cap_userns]/d' >>$tmp.sed
fi

if seinfo -x --class=file $common_flag 2>&1 \
   | grep '^[ 	][ 	]*map$' >/dev/null
then
    :
elif seinfo -x --common file 2>&1 \
   | grep '^[ 	][ 	]*map$' >/dev/null
then
    :
else
    echo '/\[pcp_pmie_exec_t] .* \[file]/s/ map / /' >>$tmp.sed
    echo '/\[pcp_pmcd_t] .* \[file]/s/ map / /' >>$tmp.sed
    echo '/\[pcp_pmie_t] .* \[hostname_exec_t]/s/ map / /' >>$tmp.sed
    echo '/\[pcp_pmcd_t] \[fsadm_exec_t]/s/ map / /' >>$tmp.sed
    echo '/\[pcp_pmcd_t] \[default_t]/s/ map / /' >>$tmp.sed
    echo '/\[pcp_pmcd_t] \[pcp_pmie_exec_t]/s/ map / /' >>$tmp.sed
    echo '/\[pcp_pmcd_t] \[pcp_tmp_t]/s/ map / /' >>$tmp.sed
    echo '/allow \[pcp_pmcd_t] \[ldconfig_exec_t]/d' >>$tmp.sed
    echo '/allow \[pcp_domain] \[file_type] : \[file]/d' >>$tmp.sed
fi

if seinfo -x --class=bpf $common_flag 2>&1 \
   | grep '^[ 	][ 	]*bpf$' >/dev/null
then
    :
else
    echo '/allow \[pcp_pmcd_t] .* \[bpf]/d' >>$tmp.sed
fi

if seinfo -a 2>&1 \
   | grep '^[ 	][ 	]*non_auth_file_type$' >/dev/null
then
    :
else
    echo '/allow \[pcp_domain] \[non_auth_file_type]/d' >>$tmp.sed
fi

cat $tmp.sed >>$seq.full

devlog_t=`seinfo -t | grep "devlog_t$"`
init_t=`seinfo -t | grep "init_t$"`
class_status=`seinfo -x --class=system $common_flag | grep "status$"`
sock_file_getattr=`seinfo -x --class=sock_file $common_flag | grep "getattr$"`
#container_runtime_tmpfs_t=`seinfo -t | grep "container_runtime_tmpfs_t$"`
container_runtime_tmpfs_t=""
non_auth_type=`seinfo -a | grep "non_auth_file_type$"`
non_security_type=`seinfo -a | grep "non_security_file_type$"`

cat $seq.out.in | _filter_outfile > $seq.out

echo "full policy modules list on the system"
$sudo semodule -l >> $seq.full
echo "Checking that pcpupstream policy module has been properly installed"
awk '{ print $1 }' $seq.full | grep "pcpupstream$"  | _filter_semodule
# real QA test starts here
echo "Checking policies."
printf '1\nq\n' | sedismod $policy_file | _filter_sedismod | _filter_sedismod1


# success, all done
status=0
exit
