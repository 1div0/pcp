#!/bin/sh
# PCP QA Test No. 1251
# basic man(1) workout for man pages
#
# Copyright (c) 2020 Ken McDonell.  All Rights Reserved.
#

seq=`basename $0`
if [ $# -eq 0 ]
then
    echo "QA output created by $seq"
else
    echo "QA output created by $seq $*"
fi

# get standard environment, filters and checks
. ./common.product
. ./common.filter
. ./common.check

which man >/dev/null 2>&1 || _notrun "No man(1) command?"

_cleanup()
{
    cd $here
    $sudo rm -rf $tmp $tmp.*
}

status=1	# failure is the default!
$sudo rm -rf $tmp $tmp.* $seq.full
trap "_cleanup; exit \$status" 0 1 2 3 15

# real QA test starts here
cat <<'End-of-File' | sed -e '/^#/d' -e '/^[ 	]*$/d' | while read sect key altname pat
# section	keyword	altname	egrep for text in man page
# for keyword, avoid case aliasing (different man's have different rules)
# and use (one of) the .SH NAME names
#

# no man page, check logic
1	really_fubar	-	beyond all recognition
# no matching text, check logic
1	pminfo		-	fubar

# simple section 1 entry
1	pminfo		-	.-T, *--helptext
# composite section 1 entry
1	pmconfirm	-	button-name
1	pmmessage	pmconfirm	button-name
1	pmquery		pmconfirm	button-name
# aliased (xM) section 1 entry
1	KERNEL_PMDAS	-	usually running as shared libraries
# special case section 1 and 3 entry
1	PCPIntro	-	Co-Pilot
3	PCPIntro	-	Co-Pilot

# simple section 3 entry
3	pmNewContext	-	PM_CTXFLAG_SECURE
# composite and aliased (xM) section 3 entry
3	pmRecord	-	pmRecordHost
3	pmRecordSetup	pmRecord	pmRecordHost
3	pmRecordControl	pmRecord	pmRecordHost

# weirdos
3	PCP::MMV	-	MMV Perl module
5	pcp.env		-	\.pcp/pcp.conf
# from src/pmdas/json (Python), not man/man?
1	pmdajson	-	generating  *JavaScript
End-of-File
do
    # *BSD man(1) really uses apropos(1) for man -k which uses a full
    # text searching, so all we can try to match on here is 
    # for each man section
    #
    echo | tee -a $seq.full
    echo "=== $key ===" | tee -a $seq.full
    lc_key=`echo "$key" | tr '[A-Z]' '[a-z']`
    lc_altname=`echo "$altname" | tr '[A-Z]' '[a-z']`
    man -k "$key" 2>$tmp.err \
    | sed >$tmp.out \
	-e "/$key: nothing appropriate/d" \
    # end
    if [ -s $tmp.out ]
    then
	tr '[A-Z]' '[a-z'] <$tmp.out >$tmp.tmp
	if grep "^$lc_key *($sect" $tmp.tmp >/dev/null
	then
	    # matching simple entry found from man -k
	    :
	elif [ X"$altname" != X- ] && grep "^$lc_altname *($sect" $tmp.tmp >/dev/null
	then
	    # matching altname entry found from man -k ... needed for
	    # *BSD where man -k is really apropos and *BSD apropos does
	    # not build index entries for symlink'd man pages
	    #
	    :
	elif grep "^$lc_key *\[[^ ]*] *($sect" $tmp.tmp >/dev/null
	then
	    # Slackware type whatis, [...] is magically crafted from .TH
	    # arguments, e.g.
	    # pcp.env [pcp]        (5)  - script ...
	    :
	elif grep "\[$lc_key] *($sect" $tmp.tmp >/dev/null
	then
	    # Slackware type whatis, [...] is our .xM string, not a keyword
	    # at the start of the line, e.g.
	    # pmRecordAddHost [pmRecord] (3)  - record ...
	    :
	else
	    # no matching entry from man -k
	    cat $tmp.err >>$seq.full
	    echo "No matching man entry for section $sect"
	fi
    else
	# no output from man -k
	cat $tmp.err >>$seq.full
	echo "No matching man entry in any section!"
    fi
    echo "--- ($sect) ---" | tee -a $seq.full
    TERM=dumb man $sect $key 2>&1 \
    | sed -e 's/_//g' -e 's/.//g' >$tmp.out
    if egrep "$pat" $tmp.out >/dev/null
    then
	echo OK
    else
	cat $tmp.out >>$seq.full
	echo "No match for pattern $pat"
    fi

done

# success, all done
status=0
exit
